1. 知乎日报项目技术栈: create-react-app, react18, redux/react-redux, react-router-dom V6,  Fetch, CSS-in-JS(styled-components)/Less, AntdMbile...
2. 从零开始构建react项目
    - 基于create-react-app创建工程化项目
        - npm i create-react-app -g
        - create-react-app 项目名
        
        - npm eject  --> 暴露webpack配置项
            - 修改脚手架默认配置
                - 配置Less: less/less-loader@8
                - 配置别名: @代表src
                - 配置浏览器兼容
                - 配置客户端启动服务的信息
                - 配置跨域代理: http-proxy-middleware
                - 配置REM响应式布局的处理: lib-flexible, postcss-pxtorem
                - 配置打包优化
                - ...
    - 准备一些项目开发必备的材料
        - public/index.html相关修改
        - src/api/http.js fetch请求的二次封装
        - src/asset/
            - utils.js 自己封装的常用的方法库
            - reset.min.css 清除浏览器默认样式
            - images 静态图片资源
            - ...
    - 配置好REM响应式布局 && 样式处理
    - 配置路由管理
    - 配置redux架子
    - 其他基础配置...
    - 逐一开发项目, 注意组件的抽离封装
    - 开发完成后
        - 项目优化
        - 封装提取
        - 内部测试
        - 部署上线
3. REM响应式布局
    - 移动端响应式布局开发一定要设置`<meta name='viewport' content="width=device-width,initial-scale=1.0, maximum=1.0, minimum=1.0, user-scaleable=no">`, 否则浏览器就会按照980的宽度渲染页面,手机宽度不足980,整个页面就会整体缩小
    - 实现REM响应式布局开发的步骤
        - 找参照的比例(例如设计稿的比例,一般都是750px),在这个比例下,给予html.fontSize一个初始值
            ```
            html {
                font-size: 100px; // 750px的设计稿中, 1REM = 100px, 后面在设计稿中测量出来的尺寸(px单位)转换为REM单位去设置样式. 设置成10px 或者 100px 是为了方便计算,不产生不好的小数点计算
            }

            .box {
                width: 3.28rem;  --> 相当于3.28*100 = 328px大小
                height: 1.64rem;
                line-height: 1.64remm;
            }
            ```
        - 我们需要根据当前设备的宽度, 计算相对于设计稿750来讲,缩放的比例. 从而让REM的转换比例,也跟着缩放
            ```
            <script>
                (function () {
                    const computed = () => {
                        let html = docuemnt.documentElement;
                        let deviceWid = html.clientWidth;
                        let designWid = 750;
                        if(deviceWid >= 750){
                            // 当屏幕最大值超过750px, 不再继续方法REM比例
                            html.style.fontSize = '100px'
                            return;
                        }
                        let ratio = deviceWid / designW * 100; //屏幕缩放后根据最新的屏幕宽和设计稿宽的比例, 计算出最新的REM对应的初始值, 这里乘以的100是上面设置的100px
                        html.style.fontSize = ratio + 'px';
                    };
                    computed();
                    window.addEventListenwer('resize', computed);
                })()
            </script>
            ```
        - 一般的,我们还会给屏幕设置最大宽度750px, 超过这个宽度,不再让REM比例继续变大了,而是让内容居中,左右两边空出来即可
            ```
            html {
                font-size: 100px;
            }
                        
            html.body {
                height: 100%;
                background: #f4f4f4
            }

            #root {
                marign: 0 auto;
                max-width: 750px;
                height: 100%;
                background: #FFF
            }

            ...
            if(deviceWid >= 750){
                // 当屏幕最大值超过750px, 不再继续方法REM比例
                html.style.fontSize = '100px'
                return;
            }
            let ratio = deviceWid / designW * 100; 
            html.style.fontSize = ratio + 'px';
            ...

            ```
    - 利用lib-flexible和postcss-pxtorem实现REM响应式布局'
        - lib-flexible: 设置REM和PX换算比例的
            - 根据设备宽度的变化自动计算 `html.style.fontSize = 设备的宽度 / 10 + 'px'`
                - 750设计稿中, 1REM = 75px
                - 375设计稿中, 1REM = 37.5px
        - postcss-pxtorem: 可以把我们写的px单位,按照当时的换算比例,自动转换为REM, 不需要我们自己算了
            - 设计稿中我们算出来多少尺寸就写多少,不需要手动转换为REM, 因为在webpack中,针对postcss-pxtorem做配置,自动帮我们做转换
            - webpack.config.js中:
                ```
                const px2rem = require('postcss-pxtorem'); //导入插件
                ....
                // 找到postcss-loader这个loader的配置位置, 给其plugins里面添加这个插件
                plugins: [
                    'post-flexbugs-fixes',
                    'postcss-normalize',
                    ...
                    // 添加我们要用的pxtorem插件的配置
                    px2rem({
                        rootValue: 75, // 基于lib-flexible, 750设计稿中,就会设置为 1REM=75px;此时在webpack编译的时候就会按照1rem=75px的比例把我们编写出来的px样式,自动转换为rem
                        propList:[*], //表示对所有文件生效,包括AntdNobile组件库也生效
                    })
                ]
                ```
            - 在入口index.js中,我们导入lib-flexible,确保在不同的设备商,可以等比例的对REM的换算比例进行缩放
            - 手动设置:超过750px后,rem比例不再继续放大, 这个max-width:750px不能写在less/css文件中,否则会被webpack编译成rem
                - 在js中处理, 参考上面写的最大宽度750px的处理, 给整个程序的根节点root设置font-size
            - 有坑: 我们在jsx文件中使用css-in-js(styled-components)写的样式px(也就是在webpack配置中不能识别css/less/sass的文件),不会被webpack转换为rem
4. 配置路由
5. 配置redux架子
6. 开发
    - 在jsx视图中,想直接导入静态资源图片,不能设置相对地址 ! 因为经过webpack打包处理,项目的结构是改变了的 !
        - 但是如果是在css样式中使用图片,使用相对地址是可以的,这是因为webpack在打包的时候,会处理css图片的导入
            - 把需要的图片进行打包
            - 把打包后的地址重新覆盖css中写的地址
        - 解决jsx使用静态图片的路径问题
            - 1. 使用绝对地址 `<image src='http://...'>`,图片部署在服务器
            - 2. `基于ES6Module模块方式导入图片`: 
                - `import xxxImage grom '@asset/images/xxx.jpg'`;
                - `<Image src='{xxxImage}'>`
    - 对于不需要频繁变化的dom元素, 使用三元运算符控制渲染不渲染DOM元素, 对于需要频繁切换显示的dom元素, 设置style样式的display:none/block设置显隐
    - 创建`IntersectionObserver`监听器,监听元素是否出现在视图当中
        ```
        useEffect( () => {
            let ob = new IntersectionObserver(changes=>{ 
                let { isInetrsecting } = changes[0];
                // 加载更多的按钮出现在视口中, 表示触底了,需要请求更多新闻列表数据
                if(isIntersecting){
                    let res = await http.queryNews(time);
                    newlist.push(res);
                    setNewsList([...newsList]); // 这里setNewsList必须是一个不同于旧的newslist地址的一个数组,否则不会触发视图更新
                }
            });
            ob.observe(loadMoreCompRef.current);

            let loadMorenComp = loadMoreCompRef.current;
            // useEffect返回一个函数,表示组件销毁的时候执行
            return () => {
                <!-- 不能这样销毁loadMoreCompRef.current,因为这个时候current已经是null了,所以需要在外面把dom元素记录下来,直接销毁这个元素的侦听
                ob.unobserve(loadMoreCompRef.current);
                 -->
                ob.unobserve(loadMorenComp);
                ob = null;
            }
        }, []); 
        ```
    - 寻找子元素的区别
        ```
        icon {
            span {
                &:nth-last-child(1){
                    // 找到icon的所有子元素的最后一个并且是span
                }
            }

            span {
                &:nth-last-of-type(1){
                    // 找到icon的所有type为span的子元素中的最后一个
                }
            }
        }
        
        ```
    - react中设置html文本
        - 通过ref获取对应的dom元素后,设置html值
        - `<div dangerouslySetInnerHTML={{ __html: info.body }}>`
    - button组件的`防抖`封装
        - 防抖: 当一个动作连续触发, 只执行最后一次.(在delay事件内重复触发,则重新计时)
            ```
            function debunce(fn, delay){
                let timer = null;
                return () => {
                    if(timer){
                        clearTimeout(timer);
                    }
                    timer = setTimeout( () => {
                        fn.apply(this, arguments);
                        timer = null;
                    }, delay);
                };
            }
            ```
        - 节流: 限制一个动作在一段时间内只能执行一次(在delay时间内重复触发,则return忽略这些重复操作,直至当前动作完成)
            ```
            function throtte(fn, delay) {
                let timer = null;
                return () => {
                    if(timer){
                        return;
                    }

                    timer = setTimeout( () => {
                        fn.apply(this, arguments);
                        timer = null;
                    }, delay);
                }
            }
            ```
    - `组件缓存`:
        - 方式1: 不是标准的组件缓存,只是数据缓存
            - a跳转b的时候,把a组件中需要的数据(或者a组件的全部虚拟dom)存储到redux/localstorage中,a组件释放,b组件加载.当b组件回到a组件的时候, a开始加载,首先判断redux/loacalstorage中是否存储了a的数据/虚拟dom,如果没有则走第一次加载逻辑的处理,如果有则把存储的数据拿来渲染
        - 方式2: 修改路由跳转机制,在路由跳转的时候,指定组件不销毁,只是display:none控制隐藏,后期从b跳转a的时候,让adisplay:block即可
        - 方式3: 把a组件的真实DOM等信息直接缓存起来,从B跳回a的时候,直接把a缓存的信息拿出来用
            - 安装`keepalive-react-component`包
            - 在App.jsx中使用`<keepAliveProvider>`包裹我们自己写的路由表创建组件`<RouterView>`
            - 在路由配置表`routes.js`中 找到想要做组件缓存的组件,给他的配置项component值用`withKeepAlive(组件/lazy处理的路由懒加载组件, {cacheId:''xxx, scroll:true})`处理即可
    - 图片上传
        ```
        // 文件上传的一个比较全面的课程,搜索 "在线Web高级开发工程师-公开课"
        // 要求formData格式
        const upload = (file) => {
            let fm = new FormDate();
            fm.append('file', file);
            return http.post('/api/upload', fm);
        }
        ```






