1. 路由跳转方案:
    - 方案1: `Link跳转`
        - Link的to可以只一个字符串,代表路由地址,也可以是一个对象
        - Link中可以添加replace字段,代表跳转路由并且替换历史记录
        ```
        <Link to='/xxx'>导航</Link>
        <Link to={
            pathname:'/xxx',
            search:'',
            state:{}
        }>导航</Link>
        <Link to='/xxx' replace>导航</Link>
        ```
    - 方案2: `编程式导航`
        - 通过props或者useHistory拿到history对象,调用其中的方法实现编程式导航
        ```
        history.push('/c');
        history.push({
            pathname:'/c',
            search:'',
            state:{}
        });
        history.replace('/c');
        ```
 2. 路由传参方案
    - 方案1: `问号传参`
        - 问号传参的内容显示在URl地址上: 丑,不安全,长度限制...
        - 传参的内容是显示的,即便在目标路由内刷新,传递的信息也在
        - `useHistory` `push` `search`, `useLocation` `search`
        ```
        // 1. B组件中某个操作跳转C组件,并通过问号传参给C
        import React from 'react';
        const B = function B(props){
            let history = useHistory();
            return <div className='view'>
                <div>B组件的内容</div>
                <button onClick={
                    // 问号传参
                    <!-- history.push('/c?id=100&name='hahaha'); -->
                    <!-- history.push({
                        pathname: '/c',
                        search: 'id=100&name='hahaha',//search的值要求是urlencoded字符串
                    }); -->
                     history.push({
                        pathname: '/c',
                        search: qs.stringify({
                            id: 100,
                            name: 'hahaha'
                        }),
                    });
                }>B组件中按钮-点击跳转C组件</<button>
            </div>;
        }
        export default B;

        // 2. 在C组件中获取传递的参数信息
        import React from 'react';
        import { useLocation } from 'react-router-dom';
        const C = function C(props){

            let location = useLocation();

            <!-- location.search : '?id=100&name=hahaha' -->
            <!-- let { id, name } = qs.parse(location.search.substring(1)); -->
            let usp = new URLSearchParams(location.search);
            let id = usp.get('id');
            let name = usp.get('name');

            return <div className='box'>
                C组件的内容
            </div>;
        }
        export default C;

        ```
    - 方案2: `路径参数`
        - 把需要传递的值作为路径的一部分`path: '/c/:id/:name?'` 问号?修饰的字段代表匹配的时候可传可不传
        - 传递的信息也在URL地址中, 比问号传参看起来漂亮一些,但是也存在安全和长度限制
        - 因为信息都在地址中,即便在目标组件内刷新,传递的信息也在
        - `路由配置表中修改path的值的形式/c/:id?/:name?`, `useHistory` `push`, (`useRouteMatch` `params`) | (`useParams` `params`)
        ```
        // 1. 路由配置表中的path字段添加传递的参数名 `path: '/c/:id/:name'`,这样跳转路由的时候必须完全匹配才行
        import { lazy } from 'react';
        import A from '@/views/A'
        import aRoutes from '@/router/aRoutes';
        const routes = [
            {
                redirect: true,
                from: '/',
                to: '/a',
                exact: true
            },
            {
                path: '/a',
                name: 'a',
                component: A,
                meta: {},
                children:[
                    aRoutes
                ]
            },
            {
                path: '/b',
                name: 'b',
                component: lazy( () => import('@/views/B')),
                meta: {},
            },
            {
                path: '/c/:id/:name', // 这里路径加上了传参的参数名id和name, 路由匹配的时候必须地址上带有这两个参数才能匹配到
                <!-- path: '/c/:id?/:name?', // 这里路径加上了传参的参数名id和name,但是是可选的, 路由匹配的时候地址上带不带id或者name都能匹配到 -->
                name: 'c',
                component: lazy( () => import('@/views/C')),
                meta: {},
            },
            {
                redirect: true,
                to: '/a'
            }
        ];
        export default routes;

        // 2. B组件中某个操作跳转C组件,并通过路径传参给C
        import React from 'react';
        const B = function B(props){
            let history = useHistory();
            return <div className='view'>
                <div>B组件的内容</div>
                <button onClick={
                     history.push('/c/100/hahaha'), // 注意这里跳转路由的时候地址的写法,带上了id和name值
                }>B组件中按钮-点击跳转C组件</<button>
            </div>;
        }
        export default B;

        // 3. 在C组件中获取传递的参数信息, 函数组件中使用hook获取,类组件可以使用props.match获取到
        import React from 'react';
        import { useRouteMatch, useParams } from 'react-router-dom';
        const C = function C(props){

            <!-- 获取方式1: 使用useRouteMatch -->
            let match = useRouteMatch();
            let { id, name } = match.params; 
            -->
            
            // 获取方式2: 使用useParams --> 仅仅在函数组件中
            let params = useParams();
            let { id, name } = params; 

            return <div className='box'>
                C组件的内容
            </div>;
        }
        export default C;
        ```
    - 方案3: `隐式传参`
        - 传递的信息不会出现在URL地址中: 安全美观,也没有限制
        - `但是在目标组件内刷新,传递的信息就丢失了`
        - `useHistory` `push` `state`, `useLocation` `state`
        ```
        // 1. B组件中某个操作跳转C组件,并通过路径传参给C
        import React from 'react';
        const B = function B(props){
            let history = useHistory();
            return <div className='view'>
                <div>B组件的内容</div>
                <button onClick={
                    history.push({
                        pathname:'/c',
                        state: {
                            id: 100,
                            name: 'hahaha'
                        }
                    })
                }>B组件中按钮-点击跳转C组件</<button>
            </div>;
        }
        export default B;

        // 2. 在C组件中获取传递的参数信息
        import React from 'react';
        import { useLocation } from 'react-router-dom';
        const C = function C(props){

           let location  = useLocation();
           let { id, name } = location.state;

            return <div className='box'>
                C组件的内容
            </div>;
        }
        export default C;
        ```

