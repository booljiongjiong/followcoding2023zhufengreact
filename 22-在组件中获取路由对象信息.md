1. 在`react-router-dom V5`中,基于Route路由匹配渲染的组件, 路由会默认给每个组件传递三个属性:
    - history
    - location
    - match
    - 我们在循环路由配置表创建组件的时候:
        - 通过`<Route component = { A }/>`这样创建的组件, 组件内部可以直接通过props获取到Route传递的history/location/match
        - 通过`<Route render = { ()=>{ return <Suspence><Component {...props} /></Suspence>} }/>`这样创建的组件, 需要手动把<Route/>传递的props传递给组件, 这样后期我们在组件中才可以基于props/hook获取到传递的属性
            - 如果是函数组件, 在函数组件内部还可以通过`useHistory``useLocation``useRouteMatch`这三个hook获取到对应的路由传递过来的信息history location match
            - 获取到history中可以拿到go() goBack() goForward() push() replace()等方法,调用便可以实现路由切换 --> 这就是`函数式导航` : 基于js方法,实现路由跳转
        ```
        // 1. @/router/index.jsx中的修改
        import React, {Suspence} from 'react';
        import { Switch, Route, Redirect } from 'react-router-dom';

        const RouterView = function RouterView(props){
            let { routes } = props;

            return <Switch>
                {
                    routes.map((item, index) => {
                        let {redirect, from, to, path, component:Component, exact} = item;
                        let config = {};
                        if(redirect){
                            config = { to };
                            if(from){
                                config.from = from;
                            }
                            if(exact){
                                config.exact = true;
                            }
                            return <Redirect key={index} {...config} />
                        }
                        config = { path };
                        if(exact){
                            config.exact = true;
                        }
                        return <Route key={index} {...config} render={(props)=>{
                            // 使用render设置组件的话: 这里就需要把Route中传递的history/location/match三个信息, 手动的传递给需要返回的组件
                            return <Suspence fallback={<>正在处理中</>}>
                                <Component {...props} />
                            </Suspence>
                        }}/>
                    })
                }
            </Switch>;
        }
        export default RouterView;

        // 2. 对应组件中获取props数据的方式 比如@/views/B.jsx
        import React from 'react';
        import { useHistory, useLocation, useRouteMatch } from 'react-router-dom';

        const B = function B(props){
            // 方式1: 可以通过props参数解构出来Route传递的信息
            let {history, location, match} = props;

            // 方式2: 使用hook获取Route传递过来的对应信息
            let history = useHistory();
            let location = useLocation();
            let match = useRouteMatch();

            return <div>
                B组件的内容
            </div>
        }

        export default B;
        ```
    - 总结1: 对于`基于<Route >`匹配渲染的组件, 在组建内部我们想要获取到这三个属性对象, 有两种情况
        - 类组件只能通过props解构获取
        - 函数组件, props和hook都可以拿到
    - 只要在`<HashRouter>`或者`<BrowserRouter>`中渲染的组件:
        - 我们在这些组件内部,基于useHistory/useLocation/useRouteMatch这些函数,就可以获取history/location/match这些对象信息, 即便这个组件不是基于<Route>匹配渲染的
        - 只有基于<Route />匹配渲染的组件,才可以基于props属性,获取这三个对象信息
        - 举个栗子:
            - 把@/views/App.jsx中的一级路由导航提取出来,变成HomeHead组件, 然后在App.js中导入进来,这样即便HomeHead组件不是基于<Route />匹配渲染的,但是他是包含在<HashRouter>里面的,所以可以基于hook组件获取到这三个对象信息
            ```
            // 1. 在@components/目录下创建HomeHead.jsx
            import React from 'react';
            import { Link } from 'react-router-dom'

            import styled from 'styled-component'
            const NavBox = styled.nav`
                // 写a标签的样式
                ...
            `
            const HomeHead = function HomeHead(){
                return <NavBox>
                    <Link to='/a'> A </Link>
                    <Link to='/b'> B </Link>
                    <Link to='/c'> C </Link>
                </NavBox>;
            }
            export default HomeHead;

            // 2. 在@/views/App.jsx中导入HomeHead组件
            import React from 'react';
            import { HashRouter } from 'react-router-dom'
            import RouterView from '@/router/RouterView';
            import routes from '@/router/routes'

            const App = function App(){
                return <HashRouter>
                    // 在App.jsx中导入HomeHead组件,即便这个组件不是基于<Route />创建的,但是因为包含在<HashRouter>中渲染,所以在这个组件内可以基于hook函数拿到三个对象信息,但是基于props是拿不到的
                    <HomeHead />

                    <div class='content'>
                    <RouterView routes = {routes} />
                    </div>
                </HashRouter>
            }
            export default App;
            ```
        - 类组件因为使用不了hook函数, 所以类组件如果没有基于<Route />匹配渲染的话,需要基于`高阶组件HOC`, 自己包裹一层进行处理(利用闭包保存信息)
            ```
            // 1. @/components/目录下创建 类组件HomeHead.jsx

            import React from 'react';
            import { Link, useHistory, useLocation, useRouteMatch } from 'react-router-dom';

            import styled from 'styled-component'
            const NavBox = styled.nav`
                // 写a标签的样式
                ...
            `

            class HomeHead extends React.Component {
                //所以这个类组件在调用的时候如果不是基于<Route/>渲染的话,只是基于<HashRouter>或者<BrowserRouter>渲染的话, 经过HOC高阶组件的代理,传递了history/location/match,, 在类组件内才可以使用this.props获取到这三个对象信息
                render(){
                    return <NavBox>
                        <Link to='/a'> A </Link>
                        <Link to='/b'> B </Link>
                        <Link to='/c'> C </Link>
                    </NavBox>;
                }
            }

            const Handle = function Handle(Component){
                // Component: 真正需要渲染的组件 HomeHead
                // 返回一个高阶组件(到处去供别的地方调用的就是HOC组件)
                return function HOC(props){
                    // props: 调用HOC传递的属性,其实这些属性原本是想传递给HomeHead的
                    // hoc是个函数组件,我们可以在这里基于Hook函数获取需要的三个对象信息,然后手动作为属性,传递给HomeHead类组件
                    let history = useHistory();
                    let location = useLocation();
                    let match = useRoutematch();
                    return <Component {...props} history={history} location={location} match={match} />
                }
            }
            
            export default Handle(HomeHead);

            // 2.在@/views/App.js中导入Homehead类组件
            import React from 'react';
            import { HashRouter } from 'react-router-dom'
            import RouterView from '@/router/RouterView';
            import routes from '@/router/routes'

            const App = function App(){
                return <HashRouter>
                    // 即便HomeHead类组件不是基于<Route/>创建的,但是在APP中导入使用的时候,是包含在<HashRouter>中渲染的,而且HomeHead类组件自己在内部导出时候使用了高阶函数HOC代理了,所以可以使用Hook函数获取到这三个对象信息history/location/match
                    <HomeHead />

                    <div class='content'>
                    <RouterView routes = {routes} />
                    </div>
                </HashRouter>
            }
            export default App;
            ```
        - 在`react-router-dom V5`版本中,自带了一个高阶组件`withRouter`, 可以用来解决 调用类组件时候没有基于<Route/>匹配渲染,只是包裹在<HashRouter>或者<BrowserRouter>中渲染时候, 类组件不能使用hook函数获取这三个对象的问题 -->也就是不需要我们自己写高阶函数处理了
            ```
            // 1. @/components/目录下创建 类组件HomeHead.jsx
            import React from 'react';
            import { Link, withRouter } from 'react-router-dom';

            import styled from 'styled-component'
            const NavBox = styled.nav`
                // 写a标签的样式
                ...
            `

            class HomeHead extends React.Component {
                //所以这个类组件在调用的时候如果不是基于<Route/>渲染的话,只是基于<HashRouter>或者<BrowserRouter>渲染的话, 经过HOC高阶组件的代理,传递了history/location/match,, 在类组件内才可以使用this.props获取到这三个对象信息
                render(){
                    return <NavBox>
                        <Link to='/a'> A </Link>
                        <Link to='/b'> B </Link>
                        <Link to='/c'> C </Link>
                    </NavBox>;
                }
            }
            
            export default withRouter(HomeHead);
            ```
    - 总结2
        - 所有组件最好都包裹在<HashRouter>或者<BrowerRouter>中渲染,只有这样,我们才能在每个组件内部获取history/location/match等信息对象
            - 1. 函数组件,并且是基于<Route/>匹配渲染的:
                - 可以在函数组件内部使用props获取这三个对象信息(如果这个组件在<Route/>里面不是用component而是使用render渲染的, 需要把render的参数props手动传递给函数组件--参照@routers/index.js中的相关处理)
                - 也可以使用useHistory/useLocation/useRouteMatch这三个hook函数获取
            - 2. 函数组件, 但并不是基于<Route/>匹配渲染的
                - 可以使用Hook函数获取
                - 可以使用withRouter代理一下这个函数组件,这样在函数组件内部就可以使用props获取了
            - 3. 类组件, 不能使用hook函数,只能基于props获取.
                - 如果类组件在基于<Router/>匹配渲染的时候,使用component渲染则天然的可以在类组件内部使用this.props获取这三个对象,如果使用render渲染,需要把render的参数props手动传递给类组件--参照@routers/index.js中的相关处理
                - 但是如果这个类组件没有基于<Route/>匹配渲染,则需要基于withRouter代理一下这个类组件




