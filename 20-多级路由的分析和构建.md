1. 多级路由
    - 每一次路由跳转,都是从一级路由开始匹配,进入匹配到的组件,再在这个组件里面匹配二级路由.....
    - HashRouter已经在一级路由配置规则里面加上了 所以子级路由不需要加了
    ```
    // 1. 在@/views目录下面创建A.jsx B.jsx C.jsx
    import React from 'react';
    import { Link, Switch, Route, Redirect } from 'react-router-dom';
    import A1 from '@/views/a/A1';
    import A2 from '@/views/a/A2';
    import A3 from '@/views/a/A3';
    import styled from 'styled-components'
    const DemoBox = styled.div`
        display: felx;
        justify-content:'flex-start';
        align-items:flect-start;

        .menu {
            a {
                display: box;
            }
        }
    `
    const A = function A(){
        // HashRouter已经在一级路由配置规则里面加上了 所以子级路由不需要加了
        return <DemoBox>
            <div className='menu'>
                <Link to='/a/a1'> A1 </Link>
                <Link to='/a/a2'> A2 </Link>
                <Link to='/a/a3'> A3 </Link>
            </div>
            <div className='view'>
                <!-- 配置二级路由规则: 需要把一级路由地址带上 不能省略 -->
                <Switch>
                    <Redirect exact from='/a' to='/a/a1'>
                    <Route path='/a/a1' component={ A1 }>
                    <Route path='/a/a2' component={ A2 }>
                    <Route path='/a/a3' component={ A3 }>
                </Switch>
            </div>
        </DemoBox>;
    }
    export default A;

    // 2. 在@/views/a目录下面创建二级路由对应的组件A1.jsx A2.jsx A3.jsx
    import React from 'react';
    import { Link } from 'react-router-dom';
    const A1 = function A1(){
        return <div className='box'>
            A1组件相信信息
            </div>
        </div>;
    }
    export default A1;

    //3. 主页面APP.jsx
    import React from 'react';
    import { HashRouter, Route, Switch, Redirct, Link } from 'react-router-dom'

    import A from './views/A'
    import B from './views/B'
    import C from './views/C'

    import styled from 'styled-component'
    const NavBox = styled.nav`
        // 写a标签的样式
        ...
    `
    const App = function App(){
        return <HashRouter>
            <NavBox>
                <Link to='/a'> A </Link>  ---> 注意这里的to不再是/ 而是/a了
                <Link to='/b'> B </Link>
                <Link to='/c'> C </Link>
            </NavBox>

            <div class='content'>
                <Switch>
                    <Redirect exact from='/' to='/a'>           ---> 如果是从首页进来的话 重定向到A页面
                    <Router path='/a' component={A} />          ---> 这里也不再是/ 而是/a 并且去掉了exact
                    <Router path='/b' component={B} />
                    <Router path='/c' render= { () => {
                        if(isLogin){
                            return { C }
                        }else{
                            return <Redirect to='/login'>
                        }
                    }} />
                    <Redirect to='/a'>                  ---> 什么都没匹配到 重定向到a页面
                </Switch>
            </div>
        </HashRouter>
    }

    // 4. 在入口文件index.jsx中挂载要渲染的APP组件
        ```
        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import App from './App';
        <!-- 使用antd组件库  -->
        import { ConfigProvider } from 'antd';
        import zhCN from 'antd/local/zh_CN';

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <Configprovider>
                <App />
            </Configprovider>
        );
        ```
    ```

2. react中路由表管理机制
    ```
    // 1. 在@/router目录下新建index.js routes.js aRoutes.js
    // 数组的每一项就是一个路由规则
        // redirect: true 此配置是重定向
        // from: 重定向路由规则的来源的地址
        // to: 重定向路由规则的重定向地址
        // exact: 是否精准匹配
        // path: 常规Route的匹配规则
        // component: 常规Route的渲染组件
        // name: 路由名称(命名路由)
        // meta: {} 路由元信息:包含当前路由的一些信息,当路由匹配后,我们可以做一些事情
        // children: [] 子路由
        // .....
    // 配置一级路由表 routes.js 
    import A from '@/views/A'
    import B from '@/views/B'
    import C from '@/views/C'

    import aRoutes from '@/router/aRoutes';

    const routes = [
        {
            redirect: true,
            from: '/',
            to: '/a',
            exact: true
        },
        {
           path: '/a',
           name: 'a',
           component: A,
           meta: {},
           children:[
               aRoutes
           ]
        },
        {
           path: '/b',
           name: 'b',
           component: B,
           meta: {},
        },
        {
           path: '/c',
           name: 'c',
           component: C,
           meta: {},
        },
        {
            redirect: true,
            to: '/a'
        }
    ];
    export default routes;

    // 2.再配置二级路由表 aRoutes.js
    import A1 from '@views/a/A1';
    import A2 from '@views/a/A2';
    import A3 from '@views/a/A3';
    const aRoutes = [
        {
            redirect: true,
            from: '/a',
            to: '/a/a1',
            exact: true
        },
        {
           path: '/a/a1',
           name: 'a-a1',
           component: A1,
           meta: {},
        },
       {
           path: '/a/a2',
           name: 'a-a2',
           component: A2,
           meta: {},
        },
        {
           path: '/a/a3',
           name: 'a-a3',
           component: A3,
           meta: {},
        },
    ];
    export default aRoutes;

    // 3.调用组件的时候,基于属性传递路由表进来,我们根据路由表,动态设定路由的匹配
        // 创建 @/router/index.js
    import React from 'react';
    import { Switch, Route, Redirect } from 'react-router-dom';

    const RouterView = function RouterView(props){
        let { routes } = props;

        return <Switch>
            {
                routes.map((item, index) => {
                    let {redirect, from, to, path, component:Component, exact} = item;
                    let config = {};
                    if(redirect){
                        config = { to };
                        if(from){
                            config.from = from;
                        }
                        if(exact){
                            config.exact = true;
                        }
                        return <Redirect key={index} {...config} />
                    }
                    config = { path };
                    if(exact){
                        config.exact = true;
                    }
                    return <Route key={index} {...config} render={()=>{
                        //统一基于render函数处理,当某个路由匹配后,后期可以在这里做一些其他事情
                        return <Component />
                    }}/>
                })
            }
        </Switch>;
    }
    export default RouterView;


    // 4. 创建@/App.jsx  --> 一级路由组件创建
    import React from 'react';
    import { HashRouter, Link } from 'react-router-dom'
    import RouterView from '@/router/RouterView';
    import routes from '@/router/routes'

    import styled from 'styled-component'
    const NavBox = styled.nav`
        // 写a标签的样式
        ...
    `
    const App = function App(){
        return <HashRouter>
            <NavBox>
                <Link to='/a'> A </Link>
                <Link to='/b'> B </Link>
                <Link to='/c'> C </Link>
            </NavBox>

            <div class='content'>
               <RouterView routes = {routes} />
            </div>
        </HashRouter>
    }


    // 5. 创建 @/view/A.jsx  --> 二级路由组件创建
    import React from 'react';
    import { Link, Switch, Route, Redirect } from 'react-router-dom';
    import routes as aRoutes from '@/router/aRoutes'
    import styled from 'styled-components'
    const DemoBox = styled.div`
        display: felx;
        justify-content:'flex-start';
        align-items:flect-start;

        .menu {
            a {
                display: box;
            }
        }
    `
    const A = function A(){
        return <DemoBox>
            <div className='menu'>
                <Link to='/a/a1'> A1 </Link>
                <Link to='/a/a2'> A2 </Link>
                <Link to='/a/a3'> A3 </Link>
            </div>
            <div className='view'>
                // 这里可以直接导入单独的二级路由配置, 也可以根据路由名称a到一级路由表中匹配到a,然后取到他的children传递给routes参数就行
                <RouterView routes = {aRoutes} />
            </div>
        </DemoBox>;
    }
    export default A;
    ```
